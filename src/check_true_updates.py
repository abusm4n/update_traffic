#!/usr/bin/env python3

# For retrospective experiments
# This script checks the analysis results for devices that have at least one update-related flag set to true, and prints out the relevant information about those devices and files
# Usage: python3 check_true_updates.py <input_directory>
# For unenrypted HTTP traffic, the update-related flags 
# python3 src/check_true_updates.py ~/update_traffic/retrospective/dataset_extracted/iot-data_http/
# For encrypted tls traffic, the update-related flags 
# python3 src/check_true_updates.py ~/update_traffic/retrospective/dataset_extracted/iot-data_tls/


# The input directory should contain the file_metadata.pickle and bin_results.json files generated by the
# analysis script, and the results will be printed to the console



import os
import json
import pickle
import argparse
import time
from collections import Counter, defaultdict

# Track execution time
start_time = time.perf_counter()

# Constants
PICKLE_FILE_CONST = "file_metadata.pickle"
ANAL_RESULTS_CONST = "bin_results.json"
UPDATE_KEYS = ["update", "firmware", "software", "download"]

# Parse arguments
parser = argparse.ArgumentParser(description='Check devices with update-related flags set to true')
parser.add_argument('input_dir', type=str, help='Input directory containing JSON and pickle files')
args = parser.parse_args()

# Load analysis results
with open(os.path.join(args.input_dir, ANAL_RESULTS_CONST), 'r') as f:
    results_data = json.load(f)
    print("[+] Loaded analysis JSON")

# Load device metadata
with open(os.path.join(args.input_dir, PICKLE_FILE_CONST), 'rb') as f:
    device_metadata = pickle.load(f)
    print("[+] Loaded device metadata")

# Helper to get device by UUID
def get_device_by_uuid(uuid):
    for device in device_metadata:
        if device['uuid'] == uuid:
            return device
    return None

# Counters
true_counter = Counter()
device_counter = Counter()
keyword_per_device = defaultdict(Counter)  # device -> keyword -> count

# Search for relevant entries
print("\nDevices with at least one update-related flag set to true:\n")

for entry in results_data.get("results", []):
    uuid = entry.get("uuid")
    device_info = get_device_by_uuid(uuid)
    if not device_info:
        continue

    device_name = device_info.get("device")
    for file_info in entry.get("file_infos", []):
        update_meta = file_info.get("update_meta", {})
        found_true = False

        for key in UPDATE_KEYS:
            if update_meta.get(key) is True:
                true_counter[key] += 1
                keyword_per_device[device_name][key] += 1
                found_true = True

        if found_true:
            device_counter[device_name] += 1
            print(f"Device: {device_name}")
            print(f"UUID: {uuid}")
            print(f"File: {file_info.get('filename')}")
            print("Update Meta:", update_meta)
            print("-" * 60)

# Summary of TRUE keyword occurrences
print("\n=== Summary of TRUE keyword occurrences ===")
total_occurrences = 0
for key in UPDATE_KEYS:
    print(f"{key}: {true_counter[key]}")
    total_occurrences += true_counter[key]
print(f"TOTAL (all keywords): {total_occurrences}")

# Device total TRUE keyword occurrences (sorted)
print("\n=== Device total TRUE keyword occurrences (sorted) ===")
sorted_device_totals = sorted(
    ((device, sum(key_counts.values())) for device, key_counts in keyword_per_device.items() if sum(key_counts.values()) > 0),
    key=lambda x: x[1],
    reverse=True
)
for device, total_for_device in sorted_device_totals:
    print(f"{device}: {total_for_device}")

# Per-device keyword TRUE count (sorted by total)
print("\n=== Per-device keyword TRUE count (sorted by total) ===")
for device, total_for_device in sorted_device_totals:
    key_counts = keyword_per_device[device]
    nonzero_keys = {k: v for k, v in key_counts.items() if v > 0}
    if nonzero_keys:
        print(f"\nDevice: {device}")
        for key, count in sorted(nonzero_keys.items(), key=lambda x: x[1], reverse=True):
            print(f"  {key}: {count}")

# Execution time
end_time = time.perf_counter()
print(f"\n[+] Script finished in {end_time - start_time:.2f} seconds")
